# Terminology & Definitions

### [并发、并行、同步、异步、阻塞、非阻塞](https://www.cnblogs.com/tracylining/p/3506673.html)

https://blog.csdn.net/historyasamirror/article/details/5778378

https://blog.csdn.net/sinat_35512245/article/details/53836580

进程(process)：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。

线程(thread)：线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。

并发(concurrency)：并发是指二个和多个事件在同一时间间隔内发生。并发是在逻辑层面上的同时工作。

并行(parallelism)：并行是指二个或多个事件在同一时刻发生。 并行是在物理层面上的同时工作。

同步(synchronous):在发出一个功能调用时，在没有得到结果之前，该调用就不返回。

异步(asynchronous)：异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。

非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

同步阻塞I/O：在这个模型中，用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。

同步非阻塞I/O：同步阻塞 I/O 的一种效率稍低的变种是同步非阻塞 I/O。在这种模型中，设备是以非阻塞的形式打开的。这意味着 I/O 操作不会立即完成，需要应用程序调用许多次来等待操作完成。这可能效率不高，因为在很多情况下，当内核执行这个命令时，应用程序必须要进行忙碌等待，直到数据可用为止，或者试图执行其他工作。

异步阻塞I/O：在这种模型中，配置的是非阻塞 I/O，然后使用阻塞 `select` 系统调用来确定一个 I/O 描述符何时有操作。使 `select` 调用非常有趣的是它可以用来为多个描述符提供通知，而不仅仅为一个描述符提供通知。对于每个提示符来说，我们可以请求这个描述符可以写数据、有读数据可用以及是否发生错误的通知。

异步非阻塞I/O：异步非阻塞 I/O 模型是一种处理与 I/O 重叠进行的模型。读请求会立即返回，说明 `read` 请求已经成功发起了。在后台完成读操作时，应用程序然后会执行其他处理操作。当 `read` 的响应到达时，就会产生一个信号或执行一个基于线程的回调函数来完成这次 I/O 处理过程。在一个进程中为了执行多个 I/O 请求而对计算操作和 I/O 处理进行重叠处理的能力利用了处理速度与 I/O 速度之间的差异。当一个或多个 I/O 请求挂起时，CPU 可以执行其他任务；或者更为常见的是，在发起其他 I/O 的同时对已经完成的 I/O 进行操作。

同步阻塞调用：得不到结果不返回，线程进入阻塞态等待。

同步非阻塞调用：得不到结果不返回，线程不阻塞一直在CPU运行。

异步阻塞调用：去到别的线程，让别的线程阻塞起来等待结果，自己不阻塞。 

异步非阻塞调用：去到别的线程，别的线程一直在运行，直到得出结果。